// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'undefined' ? null : require;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"z-form": {
		"lib": {
			"form-input-base.js": function (exports, module, require) {
				/**
				 * Created by Ivan on 10/15/2014.
				 */
				(function(  ){
				    'use strict';
				    var Z = require('z-lib' ),
				        View = require('z-view' ),
				        DOM = require('z-lib-dom' ),
				        Observable = require('z-observable' ),
				        $Observable = Z.Observable.prototype;
				    var Base = function( cfg ){
				        Z.apply(this, cfg);
				        $Observable._init.call(this);
				        this.emptyText = this.emptyText || Z.Locale.get('form.field.'+ this.type +'.emptyText', 'form.field.emptyText');
				        this.disabledText = this.disabledText || Z.Locale.get('form.field.'+ this.type +'.disabledText', 'form.field.disabledText');
				        this._setValue(this[this.valueProperty]);
				        this._initListeners();
				        this._draw();
				        this._unbindListeners();
				            Z.DOM.addListener(this.renderTo, 'click', Z.bind(this, '_mouseClick'));
				
				    },
				        blurKeyDown = function( e ){
				            var code = Z.DOM.getKeyCode(e);
				            if(code === Z.DOM.keyCode.tab){
				                this.fire('tab', e.shiftKey ? -1 : 1 );
				            }else if( code === Z.DOM.keyCode.enter || code === Z.DOM.keyCode.space ){
				                this.fire( (code === Z.DOM.keyCode.enter ? 'enter' : 'space') + 'Key', e );
				                this.blurElement.blur();
				                this.focus( void 0 );
				            }else{
				                return true;
				            }
				            return Z.DOM.stopEvent(e);
				        };
				    Base.prototype = Z.extend( $Observable, Z.extend( Z.View.Observable, {
				        focused: false,
				        focusable: true,
				        blurOnEnter: true,
				        valueProperty: 'value',
				        displayValueProperty: 'displayValue',
				        blurElementCls: 'js_z_hidden_blur_input',
				        useBlurElement: true,
				        // set inner value. call it from edit state.
				        _setValue: function (value) {
				            this[this.valueProperty] = this.dataSetter(value);
				            this._lastValue = value;
				            this.setDisplayValue(value);
				        },
				        _bindListeners: function(  ){
				            var listen = this[this.listenersProperty] = {
				                windowBlur: Z.DOM.addListener(window, 'blur', Z.bind(this, 'blur')),
				                windowClick: Z.DOM.addListener(document, 'click', Z.bind(this, 'blur')),
				                //keyboard: js.util.Keyboard.attach(this)
				            };
				        },
				        _draw: function(  ){
				            this._unbindListeners();
				            this.draw();
				            this._bindListeners();
				        },
				        setDisplayValue: function( value ){
				            this[this.displayValueProperty] = value;
				        },
				        getDisplayValue: function(  ){
				            return this[this.displayValueProperty];
				        },
				        // public interface to set value. it wouldn't fire change
				        setValue: function (value) {
				            this._setValue(value);
				            this._update();
				            return value;
				        },
				        // method that would set value and fire change event if value differs with previous one
				        changeValue: function () {
				            var value = arguments.length ? arguments[0] : this.value,
				                lastValue = this._lastValue;
				
				            if (!this.nullable && value === null)
				                return;
				
				            if (this._lastValue !== value) {
				                this._setValue(value);
				                if (this.fire('change', value, lastValue) !== false) {
				
				                }
				            }
				            this.fire('tryFireChange', value, lastValue);
				            return value;
				        },
				        _update: function(  ){
				            if (this.currentState === 'view')
				                this.inited && this.refresh();
				            else if (this.currentState === 'edit'){
				                if( this.updateEditState )
				                    this.updateEditState();
				                else
				                    throw 'base field don\'t support setValue in edit mode';
				            }
				        },
				        dataSetter: function( value ){
				            return value;
				        },
				        dataGetter: function(  ){
				
				        },
				        _createBlurElement: function(){
				            var blurElement;
				            if( !(blurElement = this.blurElement) && this.renderTo){
				                blurElement = document.createElement( 'input' );
				                blurElement.className = this.blurElementCls;
				                Z.DOM.addListener( blurElement, 'click', Z.DOM.stopEvent );
				                this.renderTo.parentNode.appendChild( blurElement );
				                Z.DOM.addListener( blurElement, 'keydown', blurKeyDown.bind(this))
				            }
				        },
				        innerFocus: function(  ){
				            if( this.useBlurElement ){
				                this._createBlurElement();
				                this.blurElement && this.blurElement.focus();//setTimeout( JS.bind(this.blurEl, 'focus'),10);
				            }
				        },
				        innerBlur: function(  ){
				            this.blur();
				            this.innerFocus();
				        },
				        die: function(){
				            this._unbindListeners();
				            this.blurElement && this.blurElement.parentNode.removeChild( this.blurElement );
				        },
				        blur: function () {
				            if( !this.focused || this.fire('tryBlur') === false )
				                return false;
				
				            this.set('focused', false);
				            this.state('view');
				
				            this.fire('blur');
				            this._unbindListeners();
				            if( this.focusValue !== this.value )
				                this.fire( 'changed', this.getValue() );
				
				            return true;
				        },
				        _mouseClick: function (e) {
				            !this.focused && this.focus( void 0 );
				            e.stopPropagation();
				        },
				        focus: function (direction) {
				            if (this.fire('tryFocus') === false || (this.disabled === true || this.enabled === false) )
				                return false;
				
				            if (!this.focused)
				                this.focusValue = this.value;
				            this.set('focused', true);
				            this.state('edit');
				
				            this.fire('focus');
				
				            return direction;
				        },
				        state: function (state) {
				            this._unbindListeners();
				            this.currentState = state;
				
				            if( this.inited ) {
				                if (this.manualRefresh)
				                    typeof this.manualRefresh === 'function' && this.manualRefresh();
				                else
				                    this._draw();
				                if( state === 'edit' ){
				                    this._bindListeners();
				                    this.innerFocus();
				                }
				                this.fire('state', state);
				                this.fire(state + 'State');
				            }
				        },
				    }));
				    Z.Form.Input.Base = Base;
				
				})();
			},
			"form.js": function (exports, module, require) {
				/**
				 * Created by Ivan on 10/15/2014.
				 */
				module.exports = require('z-lib').Form = {
				    Input: {}
				};
				require('./form-input-base');
				require('./input/text');
			},
			"input": {
				"text.js": function (exports, module, require) {
					/**
					 * Created by Ivan on 10/16/2014.
					 */
					(function(  ){
					    'use strict';
					    var Z = require('z-lib' ),
					        base = Z.Form.Input.Base,
					        $base = base.prototype,
					        Text = Z.Form.Input.Text = function( cfg ){
					            Z.apply(this, cfg);
					            base.call(this);
					        },
					        tpl = function( value ){
					            return '<input value="'+value+'">';
					        };
					    Text.prototype = Z.extend($base, {
					        emptyText: 'Empty',
					        disabledText: 'Disabled',
					        draw: function(  ){
					            this.renderTo.innerHTML = tpl(this.getDisplayValue());
					        }
					    })
					})();
				}
			}
		},
		"test.js": function (exports, module, require) {
			var Form = require('./lib/form');
			
			new Form.Input.Text({renderTo: document.getElementById('f1'), value: 123});
			new Form.Input.Text({renderTo: document.getElementById('f2'), value: 456});
		}
	},
	"z-lib": {
		":mainpath:": "lib/z.js",
		"lib": {
			"z.js": function (exports, module, require) {
				/**
				 * Created by Zibx on 10/14/2014.
				 */(function(  ){
				    'use strict';
				    var applyDeep,
				        toString = Object.prototype.toString,
				        getType = function( obj ){
				            return toString.call( obj );
				        },
				        slice = Array.prototype.slice,
				        parseFloat = this.parseFloat,
				
				        _delayList = [],
				        _delay,
				        _delayFn = function(  ){
				            _delay = false;
				            var i, _i, data;
				            for( i = 0, _i = _delayList.length; i < _i; i++ ){
				                data = _delayList[i];
				                delete data.fn.__delayed;
				                delete data.scope.__delayed;
				                data.fn.apply( data.scope, data.args || [] );
				            }
				        },
				        bind = Function.prototype.bind;
				
				    this.Math.sgn = function( num ){
				        return num >= 0 ? 1 : -1;
				    };
				
				    var Z = {
				        extend: function( obj1, obj2 ){
				            if( typeof obj1 === 'function' )
				                return Z.apply( new obj1, obj2 );
				
				            var f = function(){};
				            f.prototype = obj1;
				            return Z.apply( new f(), obj2 );
				        },
				        bind: function( scope, fn ){
				            var subFn = scope[ fn ];
				            return bind.apply( subFn, [].concat.apply( [scope],Z.toArray( arguments ).slice(2) ) );
				            //return subFn.bind.apply( subFn, [].concat.apply( [scope],Z.toArray( arguments ).slice(2) ) );
				        },
				        /* take array of values. find exact match el of el that value is before searched one. It's binary search*/
				        findBefore: function( arr, el ){
				            return arr[ Z.findIndexBefore( arr, el ) ];
				        },
				        // binary search
				        findIndexBefore: function( arr, el ){
				            var l1 = 0,
				                delta = arr.length,
				                floor = Math.floor,
				                place;
				            while( delta > 1 ){
				                delta = delta / 2;
				                if( arr[floor(l1 + delta)] > el ){
				                }else{
				                    l1 += delta
				                }
				            }
				            place = floor(l1+delta)-1;
				            return place;
				        },
				        interval: function( from, to, step ){
				            var out = [];
				            step = Math.abs( step ) || 1;
				            if( to < from )
				                for( ;from >= to; from -= step )
				                    out.push( from );
				            else
				                for( ;from <= to; from += step )
				                    out.push( from );
				            return out;
				        },
				        repeat: function( n, fn, scope ){
				            var out = [];
				            for( var i = 0; i < n; i++ )
				                out.push( fn.call( scope, i, n ) );
				            return out;
				        },
				        parseFloat: function(a){
				            return parseFloat(a) || undefined;
				        },
				        getProperty: function( prop ){
				            return function(a){
				                return a[ prop ];
				            }
				        },
				        getArgument: function( n ){
				            return function(){
				                return arguments[ n ];
				            }
				        },
				        or: function(prop){
				            return function(a){
				                return a || prop;
				            }
				        },
				        getPropertyThroughGet: function( prop ){
				            return function(a){
				                return a.get( prop );
				            }
				        },
				        sort: {
				            number: function( a, b ){
				                return a - b;
				            },
				            numberReverse: function( a, b ){
				                return b - a;
				            },
				            numberByProperty: function( name ){
				                return function( a, b ){
				                    return a[ name ] - b[ name ];
				                }
				            },
				            stringByProperty: function( name ){
				                return function( a, b ){
				                    var aKey = a[ name ], bKey = b[ name ];
				                    return aKey > bKey ? 1 : aKey < bKey ? -1 : 0;
				                }
				            }
				        },
				        checkthisPropertyExist: function (name) {
				            return this.checkPropertyExist(name, this);
				        },
				        checkPropertyExist: function (name, obj) {
				            var arr = name.split('.');
				
				            for (var i = 0, l = arr.length; i < l; i++) {
				                if (!obj[arr[i]])
				                    return false;
				                obj = obj[arr[i]];
				            }
				
				            return obj;
				        },
				        mapFn: {
				            toUpperCase: function(a){
				                return (a || '').toUpperCase();
				            }
				        },
				        reduceFn: {
				            min: function( a, b ){
				                return a != null ? ( b != null  ? Math.min( a, b ) : a ) : b;
				            },
				            max: function( a, b ){
				                return a != null ? ( b != null ? Math.max( a, b ) : a ) : b;
				            },
				            sum: function( a, b ){
				                return a - (-b);
				            },
				            diff: function( a, b ){
				                return b - a;
				            },
				            push: function( a ){
				                this.push( a );
				            },
				            concat: function( a, b ){
				                return a.concat( b );
				            }
				        },
				        filter: (function(){
				            var filterFn = function(fn, out){
				                return function(){
				                    var data = fn.apply(this, Z.toArray(arguments));
				                    if( data !== void 0 )
				                        out.push( data );
				                }
				            };
				            return function( arr, fn ){
				                var out = [];
				                Z.each( arr, filterFn(fn, out) );
				                return out;
				            }
				        })(),
				        objectDiff: function (old, newOne, emptyValue, similarValues, deep) {
				            var getType = Z.getType,
				
				                hash = {},
				                diff = {},
				                i, j,
				                val1, val2,
				                type1, type2,
				                differences = false;
				
				            similarValues = Z.arrayToObj(similarValues || []);
				
				
				            deep = deep === void 0 ? true : deep;
				
				            for( i in old )
				                old.hasOwnProperty( i ) &&
				                    ( hash[ i ] = old[i] );
				
				            for( i in newOne )
				                newOne.hasOwnProperty( i ) &&
				                    ( hash[ i ] === void 0 && newOne[ i ] !== void 0 ) &&
				                    ( differences = true ) &&
				                ( diff[i] = newOne[ i ] );
				
				            for( i in hash )
				                if( hash.hasOwnProperty( i ) ){
				                    if( ( val1 = hash[i] ) === ( val2 = newOne[i] ) )
				                        continue;
				
				                    if( ( similarValues[ val1 ] === true ) === similarValues[ val2 ] )
				                        continue;
				
				                    if( val2 === void 0 ){
				                        ( differences = true ) && (diff[i] = emptyValue );
				                        continue;
				                    }
				
				                    if( ( type1 = getType(val1) ) !== ( type2 = getType(val2) ) ){
				                        ( differences = true ) && ( diff[i] = val2 );
				                        continue;
				                    }
				
				                    // here elements have the same type
				                    if( type1 === '[object Array]' ){
				                        if( (j = val1.length ) !== val2.length ){
				                            ( differences = true ) && ( diff[i] = val2 );
				                            continue
				                        }
				
				                        for( ;j; ){
				                            --j;
				                            if( val1[ j ] !== val2[ j ] ){
				                                ( differences = true ) && ( diff[i] = val2 );
				                                continue;
				                            }
				                        }
				                    }else if( type1 === '[object Object]' ){
				                        if (deep === true)
				                            if (Z.objectDiff(val1, val2, emptyValue, similarValues, deep) !== false)
				                                ( differences = true ) && ( diff[i] = val2 );
				                    }else{
				                        ( differences = true ) && ( diff[i] = val2 );
				                    }
				
				
				                }
				
				            return differences ? diff : false;
				        },
				        pipe: function(){
				            var args = Z.toArray(arguments);
				            return function(){
				                var out = Z.toArray(arguments);
				                for( var i = 0, _i = args.length; i < _i; i++)
				                    out = [args[i].apply( this, out )];
				                return out[0];
				            }
				        },
				        /*
				         Function: doAfter
				
				         Takes lots of functions and executes them with a callback function in parameter. After all callbacks were called it executes last function
				
				         */
				        doAfter: function(){
				            var i = 0,
				                _i = arguments.length - 1,
				                counter = _i,
				                callback = arguments[ _i ],
				                data = {};
				
				            for( ; i < _i; i++ ){
				                (function( callFn, i ){
				                    var fn = function(){
				                        data[ i ] = arguments;
				
				                        if( fn.store != null )
				                            data[ fn.store ] = arguments;
				
				                        if( !--counter )
				                            callback( data );
				
				                    };
				
				                    callFn( fn )
				                })( arguments[i], i );
				            }
				        },
				        zipObject: function( arr1, arr2 ){
				            var out = {};
				            arr1.forEach(function( el, i ){
				                out[el] = arr2[i];
				            } );
				            return out;
				        },
				        emptyFn: function(){},
				        /*
				         proxy config
				         {
				         fromKey: toKey        = rename
				         fromKey: !toValue     = delete property if toKey === value
				         !fromKey: toValue     = add value to fromKey if it's not exists
				         }
				         */
				        proxy: function( proxy, obj ){
				            var newObj = Z.clone( obj );
				            Z.each( proxy, function( key, val ){
				
				                if( val && val.charAt(0) == '!' ){
				                    if( obj[ key ] == val.substr( 1 ) )
				                        delete newObj[ key ];
				                }else if( key.charAt(0) == '!' && newObj[ key.substr( 1 ) ] === undefined ){
				                    newObj[ key.substr( 1 ) ] = val;
				                }else{
				                    if( obj[ key ] && val )
				                        newObj[ val ] = obj[ key ];
				                    delete newObj[ key ];
				                }
				            });
				            return newObj;
				        },
				        clone: function( obj, deep ){
				            var out, i, cloneDeep = deep != null;
				            switch( getType( obj ) ){
				                case '[object Array]':
				                    out = [];
				                    if( cloneDeep )
				                        for( i = obj.length; i; ){
				                            --i;
				                            out[ i ] = Z.clone( obj[ i ], true );
				                        }
				                    else
				                        for( i = obj.length; i; ){
				                            --i;
				                            out[ i ] = obj[ i ];
				                        }
				                    return out;
				                case '[object Object]':
				                    out = {};
				                    if( cloneDeep )
				                        for( i in obj )
				                            out[ i ] = Z.clone( obj[ i ], true );
				                    else
				                        for( i in obj )
				                            out[ i ] = obj[ i ];
				
				
				                    return out;
				            }
				            return obj;
				        },
				        applyIfNot: function( el1, el2 ){
				            var i, undefined = void 0;
				
				            for( i in el2 )
				                el1[ i ] === undefined && ( el1[ i ] = el2[ i ] );
				
				            return el1;
				        },
				        /*
				         Function: apply
				
				         Applies el2 on el1. Not recursivly
				
				         Parameters:
				         el1 - object to apply on
				         el2 - applieble object
				
				         Return:
				         el1
				
				         See also:
				         <Z.applyLots> <Z.applyDeep>
				         */
				        apply: function( el1, el2 ){
				            var i;
				
				            for( i in el2 )
				                el1[ i ] = el2[ i ];
				
				            return el1;
				        },
				        /*
				         Function: slice
				
				         Array.prototype.slice usually useful to convert arguments to Array
				
				         Parameters:
				         args - Array || arguments
				         start - start position
				         length - count of items
				
				         Return:
				         array
				
				         Example:
				         (code)
				         (function (){
				         return Z.slice.call( arguments, 1 );
				         })(1,2,3,4,5)
				         // Output:
				         //   [2,3,4,5]
				         (end code)
				         */
				        slice: slice,
				
				        toArray: function( obj ){
				            return slice.call( obj );
				        },
				        /*
				         Function: applyLots
				         Apply more then one objects
				
				         Parameters:
				         el1 - object to apply on
				         args[ 1-inf ] - applieble objects
				
				         Return:
				         el1
				
				         See also:
				         <Z.apply> <Z.applyDeep>
				         */
				        applyLots: function( el1 ){
				            var i, j, el2, applyL = arguments.length;
				            for( j = 1; j < applyL; j++ ){
				                el2 = arguments[ j ];
				                for( i in el2 )
				                    el1[ i ] = el2[ i ];
				            }
				            return el1;
				        },
				
				        /*
				         Function: applyDeep
				         Recursivly aplly el2 on el1. Work propper only with objects. Was designed to apply plugins.
				
				         Parameters:
				         el1 - object to apply on
				         el2 - applieble object
				
				         Return:
				         el1
				
				         See also:
				         <Z.apply> <Z.applyLots>
				         */
				        applyDeep: function(a,b){
				            var me = applyDeep,
				                i, el;
				
				            for( i in b ){
				                el = a[ i ];
				                if( el && typeof el === 'object' ){
				                    me( el,  b[ i ] );
				                }else
				                    a[ i ] = b[ i ];
				            }
				            return a;
				        },
				
				        /*
				         Function: isArray
				         Test is argument an Array
				
				         Parameters:
				         obj - object
				
				         Return:
				         bool - true if array, false if not
				
				         */
				        isArray: function( obj ){
				            return getType( obj ) === '[object Array]';
				        },
				
				        /*
				         Function: each
				         Itterate Objects && Arrays.
				
				         Object gets:
				         key  - key
				         value  - value
				
				         this  - element
				
				         Array gets:
				         value  - value
				         i  - index of element in array
				
				         this  - element
				
				
				         Parameters:
				         el - Object || Array
				         callback - function which would be called with each item
				
				         See also:
				         <eachReverse>
				         */
				        each: function( el, callback ){
				            var i, _i, out;
				
				            if( el === null || el === undefined )
				                return false;
				
				            if( Z.isArray( el ) ){
				                for( i = 0, _i = el.length; i < _i; i++ ){
				                    out = callback.call( el[i], el[i], i );
				                    if( out !== undefined )
				                        return out;
				                }
				            }else{
				                for( i in el )
				                    if( el.hasOwnProperty( i ) ){
				                        out = callback.call( el[i], i, el[i] );
				                        if( out !== undefined )
				                            return out;
				                    }
				
				            }
				        },
				        /*
				         Function: eachReverse
				         Itterate Objects && Arrays in reverse order.
				
				         Object gets:
				         key  - key
				         value  - value
				
				         this  - element
				
				         Array gets:
				         value  - value
				         i  - index of element in array
				
				         this  - element
				
				
				         Parameters:
				         el - Object || Array
				         callback - function which would be called with each item
				
				         See also:
				         <each>
				         */
				        eachReverse: function( el, callback ){
				            var i, _i, item;
				
				            if( el === null || el === undefined )
				                return false;
				
				            if( Z.isArray( el ) ){
				                for( i = el.length; i; ){
				                    --i;
				                    callback.call( el[i], el[i], i );
				                }
				            }else{
				                _i = [];
				                for( i in el ){
				                    if( el.hasOwnProperty( i ) )
				                        _i.push( [ i, el[i] ] )
				                }
				                for( i = _i.length; i; ){
				                    item = _i[ --i ];
				                    callback.call( item[1], item[0], item[1] );
				                }
				
				            }
				        },
				        /*
				         Function: makeArray
				         wraps single element with Array if not
				
				         Parameters:
				         el - Element
				
				         Return:
				         Array
				         */
				        makeArray: function( obj ){
				            return obj !== void 0 ? ( this.isArray( obj ) ? obj : [ obj ] ) : [];
				        },
				        /*
				         Function: arrayRotate
				         Lets imagine an array as a looped object, where after last element goes the first one.
				
				         Parameters:
				         arr - Array
				         val - offset of rotation
				
				         Return:
				         Array
				
				         Example:
				         Z.arrayRotate([1,2,3,4,5],2) => (3,4,5,1,2)
				         */
				        arrayRotate: function( arr, i ){
				            return arr.slice(i).concat(arr.slice(0,i));
				        },
				        /*
				         Function: arrayToObj
				         Convert Array to hash Object
				
				         Parameters:
				         arr - Array
				         val [optional] - value that would be setted to each member (default is _true_)
				
				         Return:
				         Hash object
				         */
				        arrayToObj: function( arr, val ){
				            var i = 0, _i = arr.length,
				                newVal = val || true,
				                out = {};
				            if( arr === null || arr === undefined ) return out;
				
				            for( ; i < _i; i++ ){
				                out[ arr[ i ] ] = newVal;
				            }
				            return out;
				        },
				        makeHash: function( arr, hash, hashVal ){
				            var out = {}, i, item;
				            if( typeof hashVal === 'function' )
				                if( typeof hash === 'function' ){
				                    for( i = arr.length; i; ){
				                        item = arr[ --i ];
				                        out[ hash( item ) ] = hashVal(item);
				                    }
				                }else{
				                    for( i = arr.length; i; ){
				                        item = arr[ --i ];
				                        out[ item[ hash ] ] = hashVal(item);
				                    }
				                }
				            else
				            if( typeof hash === 'function' ){
				                for( i = arr.length; i; ){
				                    item = arr[ --i ];
				                    out[ hash( item ) ] = item;
				                }
				            }else{
				                for( i = arr.length; i; ){
				                    item = arr[ --i ];
				                    out[ item[ hash ] ] = item;
				                }
				            }
				            return out;
				        },
				        map: function(el, f){
				            var out = [],
				                toArray = Z.toArray;
				            Z.each(el, function(){
				                out.push( f.apply( this, toArray(arguments) ) );
				            });
				            return out;
				        },
				        isEmpty: function( obj ){
				            var undefined = void 0;
				            if( getType( obj ) === '[object Object]' )
				                for( var i in obj ){
				                    if( obj.hasOwnProperty(i) && obj[i] !== undefined )
				                        return false
				                }
				            return true;
				        },
				        allArgumentsToArray: function(args){
				            return Array.prototype.concat.apply([],Z.toArray(args).map( Z.makeArray.bind(Z) ));
				        }
				    };
				    module && (module.exports = Z);
				}).call(
				    // get eval from its nest
				    (1,eval)('this')
				);
			}
		}
	},
	"z-lib-dom": {
		":mainpath:": "lib/z-lib-dom.js",
		"lib": {
			"z-lib-dom.js": function (exports, module, require) {
				(function() {
				    var Z = require('z-lib');
				    var DOM = Z.DOM = {
				        init: function(){
				            if (typeof window.addEventListener === 'function') {
				                this.addListener = function (el, type, fn) {
				                    el.addEventListener(type, fn, false);
				                    return {remove: DOM.removeListener.bind(DOM, el, type, fn)};
				                };
				                this.removeListener = function (el, type, fn) {
				                    el.removeEventListener(type, fn, false);
				                };
				            } else if (typeof document.attachEvent === 'function') { // IE
				                this.addListener = function (el, type, fn) {
				                    el.attachEvent('on' + type, fn);
				                    return {remove: DOM.removeListener.bind(DOM, el, type, fn)};
				                };
				                this.removeListener = function (el, type, fn) {
				                    el.detachEvent('on' + type, fn);
				                };
				            } else { // older browsers
				                this.addListener = function (el, type, fn) {
				                    el['on' + type] = fn;
				                    return {remove: DOM.removeListener.bind(DOM, el, type, fn)};
				                };
				                this.removeListener = function (el, type) {
				                    el['on' + type] = null;
				                };
				            }
				        },
				        stopEvent: function( e ){
				            e.stopPropagation();
				            e.preventDefault();
				            return false;
				        },
				        keyCode: {
				            backspace: 8,
				            comma: 188,
				            'delete': 46,
				            'del': 46,
				            down: 40,
				            end: 35,
				            enter: 13,
				            escape: 27,
				            home: 36,
				            left: 37,
				            numpad_add: 107,
				            numpad_decimal: 110,
				            numpad_divide: 111,
				            numpad_enter: 108,
				            numpad_multiply: 106,
				            numpad_subtract: 109,
				            page_down: 34,
				            page_up: 33,
				            period: 190,
				            right: 39,
				            space: 32,
				            tab: 9,
				            up: 38,
				            any: -1
				        },
				        getKeyCode: function( e ){
				            return String.fromCharCode(e.which || e.keyCode).toLowerCase().charCodeAt(0);
				        },
				        addOnceListener: function( el, type, fn ){
				            var wrapFn = function(){
				                window.DOM.removeListener(el, type, wrapFn);
				                fn.apply( this, Array.prototype.slice.call( arguments ) );
				            };
				            this.addListener( el, type, wrapFn);
				        },
				        removeClass: function( el, name ){
				            el.className = ((' '+el.className+' ').replace( ' '+name+' ', ' ')).trim();
				        },
				        addClass: function( el, name ){
				            !this.hasClass( el, name ) && (el.className += ' '+ name);
				        },
				        hasClass: function( el, name ){
				            return (' '+el.className+' ').indexOf( ' '+name+' ' ) > -1;
				        },
				        toggleClass: function( el, name ){
				            this[ (this.hasClass(el, name) ? 'remove' : 'add' ) + 'Class' ]( el, name );
				        },
				        getOffset: function( target ){
				            target = target || this.target;
				            var left = this.pageX,
				                top = this.pageY,
				                width = target.offsetWidth,
				                height = target.offsetHeight;
				
				            if (target.offsetParent) {
				                do {
				                    left -= target.offsetLeft;
				                    top -= target.offsetTop;
				                } while( target = target.offsetParent );
				            }
				            return [left, top, width, height];
				        },
				        getXY: function( e ){
				            if ( e.pageX == null && e.clientX != null ) {
				                DOM.getXY = function( e ){
				                    var eventDoc = e.target.ownerDocument || document,
				                        doc = eventDoc.documentElement,
				                        body = eventDoc.body;
				
				                    return {
				                        x: e.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 ),
				                        y: e.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 )
				                    };
				                };
				            }else{
				                DOM.getXY = function( e ){
				                    return {
				                        x: e.pageX,
				                        y: e.pageY
				                    }
				                };
				            }
				            return DOM.getXY( e );
				        },
				        _readyList: [],
				        inited: false,
				        ready: function( fn ){
				            this._readyList.push(fn);
				            this._ready();
				        },
				        _ready: function(  ){
				            if( this.inited ){
				                while( this._readyList.length ){
				                    this._readyList.shift()();
				                }
				            }
				        },
				        tplRenderer: function( name ){
				            var obj = new LogicTplUnit( w[name] );
				            return function(data){return obj.f(data || {});};
				        }
				    };
				    DOM.init();
				    /*Z && Z.register('[object HTMLDivElement]', {
				        addClass: function(name){
				            for( var els = this.els, i = els.length; i; )
				                DOM.addClass(els[--i], name);
				            return this;
				        },
				        removeClass: function( name ){
				            for( var els = this.els, i = els.length; i; )
				                DOM.removeClass(els[--i], name);
				            return this;
				        },
				        toggleClass: function( name ){
				            for( var els = this.els, i = els.length; i; )
				                DOM.toggleClass(els[--i], name);
				            return this;
				        },
				        hasClass: function( name ){
				            for( var els = this.els, i = els.length; i; )
				                if( DOM.hasClass(els[--i], name) )
				                    return true;
				            return false;
				        }
				    });
				    Z && Z.register('[object String]', {
				
				    }, function( el ){
				        return Z(Array.prototype.slice.call(document.querySelectorAll(el)),'[object HTMLDivElement]');
				    });
				        //Z.selfy(DOM, 'addListener,removeListener,addOnceListener, addClass,removeClass,!hasClass,toggleClass,!getOffset'));
				*/
				    var readyFn = function(){
				        DOM.inited = true;
				        DOM._ready();
				
				    };
				
				
				    function r( f ){
				        /in/.test( document.readyState ) ? setTimeout( r.bind( null, f ), 90 ) : f()
				    }
				    r( readyFn );
				
				
				    return DOM;
				})();
			}
		}
	},
	"z-observable": {
		":mainpath:": "lib/z-observable.js",
		"lib": {
			"z-observable.js": function (exports, module, require) {
				/**
				 * Created by Ivan on 10/19/2014.
				 */
				
				(function(ClassLoader, js){
				    'use strict';
				    var Z = require('z-lib');
				
				    var slice = Array.prototype.slice;
				    var eventBuilder = function( el, scope ){
				        var out = [scope],
				            txt = [], names = [], counter = 0, fireFn;
				        Z.each( el.list, function( el ){
				
				            out.push( el.fn, el.caller );
				            names.push( 'f'+ counter, 'c'+ counter );
				            txt.push('f'+ counter +'.apply('+ 'c'+ counter + ', (data[dataLength] = c'+ counter+') && data) === false');
				            counter++;
				        });
				        names.push('data');
				        !el.plain && txt.reverse();
				        fireFn = new Function(
				            names.join(','),
				            'var dataLength = data.length;return (' + txt.join('||')+')? false : this;'
				        );
				        el.fn = fireFn.bind.apply(fireFn, out);
				    };
				    var proto = {
				        /*
				         Function: _init
				         Runs in class init. Adds uniq `eventList` object to class
				
				         */
				        _init: function(){
				            this.eventList = {};//this._EventList ? new this._EventList().eventList : {};
				            this.on(this.listeners);
				        },
				        /*_initPrototype: function(  ){
				            var tmp = function(){ this.eventList = {}; };
				            tmp.prototype = proto;
				
				            this._EventList = function(){};
				            this._EventList.prototype = { eventList: (new tmp()).on( this.listeners ).eventList };
				        },*/
				        /*
				         Function: fireEvent (fire)
				         Fires an event
				
				
				
				         Parameters:
				         eventName - name of event
				         args[ 1 .. inf ] - arguments to event callbacks
				
				         */
				        fireEvent : function fire( eventName ) {
				
				            var data = slice.call( arguments, 1 ),
				                event = this.eventList[ eventName ],
				                allEvents = this.eventList[ '*' ],
				                prevented;
				
				            //eventName !== 'mousemove' && console.log(eventName, data, this._className, this.innerEl, this.el);
				            allEvents && allEvents.fn(slice.call( arguments ));
				
				            if( event )
				                return event.fn( data );
				            else{
				                prevented = false;
				                if( this.listeners && this.listeners[ eventName ] ){
				                    event = [ { fn: this.listeners[ eventName ], caller: this } ];
				                    var i, subscriber, dataLength = data.length;
				
				                    /*debug cut*/
				                    /*if( event.length > 10 ){
				                     console.warn('Strange event `'+ eventName +'`, ' + event.length + ' handlers attached')
				                     }*//*/debug cut*/
				                    for( i = event.length; i ; ){
				                        subscriber = event[ --i ];
				                        data[ dataLength ] = subscriber.caller;
				                        prevented = prevented || subscriber.fn.apply( subscriber.caller || subscriber, data ) === false;
				                    }
				
				                }
				            }
				
				            return prevented ? false : this;
				        },
				        /* When you don't want this event to be fired too frequently.
				           But it still would be fired on first call and last call would be done as well.*/
				        fireSchedule: function( interval, eventName ){
				            var eventList = this.eventList,
				                event = eventList[ eventName ],
				                date, nextCall;
				            if( !event )
				                return;
				
				            nextCall = event.nextCall;
				
				            date = (new Date()).valueOf();
				            event.args = slice.call( arguments, 1 );
				            if( !nextCall || nextCall <= date ){
				                event.nextCall = date + interval;
				                this.fire.apply( this, event.args );
				            }else if( nextCall > date ){
				                if( event.timeout )
				                    return;
				                event.timeout = setTimeout(function(){
				                    event.timeout = void 0;
				                    event.nextCall = date + interval;
				                    this.fire.apply( this, event.args );
				                }.bind(this), interval + 2 );
				            }
				        },
				
				        /*
				         Function: on
				
				         Subscribe callback on event
				
				         Parameters:
				         eventName - name of event
				         fn - callback function
				         [ caller = this ] - scope to call on ( default: this )
				
				         */
				        on : function on( eventName, fn, caller ) {
				            if( typeof eventName !== 'string' ){ // object of events
				                for( var i in eventName ){
				                    if( eventName.hasOwnProperty( i ) )
				                        this.on( i, eventName[ i ] );
				                }
				            }else{
				                if( eventName.indexOf(',') > -1 ){
				                    Z.each( eventName.split(','), function( eventName ){
				                        this.on( eventName.trim(), fn, caller );
				                    }.bind(this) );
				                }else{
				                    var eventList = this.eventList,
				                        data = {fn : fn, caller : caller || this };
				
				                    !eventList && (eventList = {});
				                    (eventList[eventName] || ( eventList[eventName] = { list: [] } )).list.push( data );
				                    eventList[eventName] = { list: eventList[eventName].list.slice() };
				                    if( eventList[eventName].list.length > 10 ){
				                        window.console.warn('Strange event `'+ eventName +'`, ' + eventList[ eventName ].length + ' handlers attached');
				                    }/*/debug cut*/
				                    eventBuilder( eventList[eventName], this );
				                }
				            }
				            return this;
				        },
				
				        once: function( name, fn, scope ){
				            var wrap = function(){
				                fn.apply(scope, Z.toArray(arguments));
				                this.un(name, wrap);
				            };
				            this.on( name, wrap, this );
				        },
				        removableOn: function( eventName, fn, caller ){
				            var wrap = function(){
				                fn.apply(caller, Z.toArray(arguments));
				            };
				            this.on( eventName, wrap, this );
				
				            return {remove: function(  ){
				                this.un(eventName, wrap);
				            }.bind(this)};
				
				        },
				        /*
				         Function: un
				
				         Unsubscribe callback for event. It's important that fn shoul be same function pointer, that was pased in <on>
				
				         Parameters:
				         eventName - name of event
				         fn - callback function
				
				         */
				        un : function un( eventName, fn ){
				            var event = this.eventList[ eventName ],
				                i, eventList;
				
				
				
				            if( event !== undefined )
				                if( fn === undefined )
				                    delete this.eventList[ eventName ];
				                else{
				                    for( eventList = event.list, i = eventList.length ; i ; )
				                        if( eventList[ --i ].fn === fn )
				                            eventList.splice( i, 1 );
				
				                    if( !eventList.length )
				                        delete this.eventList[ eventName ];
				                    else
				                        eventBuilder( event, this );
				                }
				
				
				            return this;
				        },
				        /*
				         Function: set
				
				         Set parameter with events
				         */
				
				        set: function( param, value ){
				            var oldValue = this[ param ];
				            if( this.fireEvent( param + 'BeforeSet', value, oldValue ) === false )
				                return false;
				            this[ param ] = value;
				            this.fireEvent( param + 'Set', value, oldValue );
				            return value;
				        },
				
				        _unbindListeners: function () {
				            var listen = this[ arguments[0] || 'listen' ];
				
				            if (listen) {
				                Z.each(listen, function() {
				                    if (this && typeof this.remove == "function")
				                        this.remove();
				                    else if (typeof this === 'function')
				                        this();
				                });
				            }
				        },
				
				        _initListeners: function () {
				            this.listen = {};
				        }
				    };
				    proto.fire = proto.fireEvent;
				    Z.Observable = function(){
				        this._init();
				    };
				    Z.Observable.prototype = proto;
				    return Z.Observable;
				})();
			}
		}
	},
	"z-view": {
		":mainpath:": "lib/z-view.js",
		"lib": {
			"z-view.js": function (exports, module, require) {
				/**
				 * Created by Ivan on 10/17/2014.
				 */
				(function(  ){
				    'use strict';
				    var Z = require('z-lib' ),
				        DOM = require('z-lib-dom');
				    var View = Z.View = function(  ){
				
				    };
				    View.prototype = {};
				    View.Observable = {
				        listenersProperty: '_listen',
				        _unbindListeners: function( listenersProperty ){
				            var listen = this[ listenersProperty || this.listenersProperty],
				                i, remove;
				
				            if (listen)
				                for( i in listen )
				                    listen.hasOwnProperty( i ) &&
				                        (remove = listen[i]) &&
				                            (
				                                (typeof remove.remove === 'function' && remove.remove())
				                                ||
				                                (typeof remove === 'function' && remove)
				                            );
				
				        },
				
				        _initListeners: function () {
				            this[this.listenersProperty] = {};
				        }
				    }
				})();
			}
		}
	}
})("z-form/test");
